var documenterSearchIndex = {"docs":
[{"page":"Home","location":"#Delimited-Files","title":"Delimited Files","category":"section","text":""},{"page":"Home","location":"#DelimitedFiles.readdlm-Tuple{Any, AbstractChar, Type, AbstractChar}","title":"DelimitedFiles.readdlm","category":"method","text":"readdlm(\n    source, delim::AbstractChar, T::Type, eol::AbstractChar\n    ; header=false, skipstart=0, skipblanks=true,\n      use_mmap=false, quotes=true,\n      dims::NTuple{2,Integer},\n      comments=false, comment_char='#'\n)\n\nRead a matrix from the source where each line (separated by eol) gives one row, with elements separated by the given delimiter. The source can be a text file, stream or byte array. Memory mapped files can be used by passing the byte array representation of the mapped segment as source.\n\nIf T is a numeric type, the result is an array of that type, with any non-numeric elements as NaN for floating-point types, or zero. Other useful values of T include String, AbstractString, and Any.\n\nKeyword options:\n\nheader::Bool=false:   if true, the first row of data will be read as header and the tuple   (data_cells, header_cells) is returned instead of only data_cells.\nskipstart::Integer=0:   if skipstart > 0, ignore the corresponding number of initial lines from the input.\nskipblanks::Bool=true:   if true, blank lines in the input will be ignored.\nuse_mmap::Bool=false:   if true, the file specified by source is memory mapped for potential   speedups if the file is large.    On a Windows filesystem, use_mmap should not be set   to true unless the file is only read once and is also not written to.   Some edge cases exist where an OS is Unix-like but the filesystem is Windows-like.\nquotes::Bool=true:   if true, columns enclosed within double-quote (\") characters are allowed to   contain new lines and column delimiters. Double-quote characters within a quoted field must   be escaped with another double-quote.\ndims::NTuple{2,Integer}:   a tuple of the expected rows and columns (including header, if any) may speed up   reading of large files.\ncomments::Bool=false:   if true, lines beginning with comment_char and text following comment_char in any line   are ignored.\ncomment_char::Char='#':   the character that marks the beginning of a comment.\n\nExamples\n\njulia> using DelimitedFiles\n\njulia> x = [1; 2; 3; 4];\n\njulia> y = [5; 6; 7; 8];\n\njulia> open(\"delim_file.txt\", \"w\") do io\n           writedlm(io, [x y])\n       end\n\njulia> readdlm(\"delim_file.txt\", '\\t', Int, '\\n')\n4×2 Matrix{Int64}:\n 1  5\n 2  6\n 3  7\n 4  8\n\njulia> rm(\"delim_file.txt\")\n\n\n\n\n\n"},{"page":"Home","location":"#DelimitedFiles.readdlm-Tuple{Any, AbstractChar, AbstractChar}","title":"DelimitedFiles.readdlm","category":"method","text":"readdlm(source, delim::AbstractChar, eol::AbstractChar; options...)\n\nIf all data is numeric, the result will be a numeric array. If some elements cannot be parsed as numbers, a heterogeneous array of numbers and strings is returned.\n\n\n\n\n\n"},{"page":"Home","location":"#DelimitedFiles.readdlm-Tuple{Any, AbstractChar, Type}","title":"DelimitedFiles.readdlm","category":"method","text":"readdlm(source, delim::AbstractChar, T::Type; options...)\n\nThe end of line delimiter is taken as \\n.\n\nExamples\n\njulia> using DelimitedFiles\n\njulia> x = [1; 2; 3; 4];\n\njulia> y = [1.1; 2.2; 3.3; 4.4];\n\njulia> open(\"delim_file.txt\", \"w\") do io\n           writedlm(io, [x y], ',')\n       end;\n\njulia> readdlm(\"delim_file.txt\", ',', Float64)\n4×2 Matrix{Float64}:\n 1.0  1.1\n 2.0  2.2\n 3.0  3.3\n 4.0  4.4\n\njulia> rm(\"delim_file.txt\")\n\n\n\n\n\n"},{"page":"Home","location":"#DelimitedFiles.readdlm-Tuple{Any, AbstractChar}","title":"DelimitedFiles.readdlm","category":"method","text":"readdlm(source, delim::AbstractChar; options...)\n\nThe end of line delimiter is taken as \\n. If all data is numeric, the result will be a numeric array. If some elements cannot be parsed as numbers, a heterogeneous array of numbers and strings is returned.\n\nExamples\n\njulia> using DelimitedFiles\n\njulia> x = [1; 2; 3; 4];\n\njulia> y = [1.1; 2.2; 3.3; 4.4];\n\njulia> open(\"delim_file.txt\", \"w\") do io\n           writedlm(io, [x y], ',')\n       end;\n\njulia> readdlm(\"delim_file.txt\", ',')\n4×2 Matrix{Float64}:\n 1.0  1.1\n 2.0  2.2\n 3.0  3.3\n 4.0  4.4\n\njulia> z = [\"a\"; \"b\"; \"c\"; \"d\"];\n\njulia> open(\"delim_file.txt\", \"w\") do io\n           writedlm(io, [x z], ',')\n       end;\n\njulia> readdlm(\"delim_file.txt\", ',')\n4×2 Matrix{Any}:\n 1  \"a\"\n 2  \"b\"\n 3  \"c\"\n 4  \"d\"\n\njulia> rm(\"delim_file.txt\")\n\n\n\n\n\n"},{"page":"Home","location":"#DelimitedFiles.readdlm-Tuple{Any, Type}","title":"DelimitedFiles.readdlm","category":"method","text":"readdlm(source, T::Type; options...)\n\nThe columns are assumed to be separated by one or more whitespaces. The end of line delimiter is taken as \\n.\n\nExamples\n\njulia> using DelimitedFiles\n\njulia> x = [1; 2; 3; 4];\n\njulia> y = [5; 6; 7; 8];\n\njulia> open(\"delim_file.txt\", \"w\") do io\n           writedlm(io, [x y])\n       end;\n\njulia> readdlm(\"delim_file.txt\", Int64)\n4×2 Matrix{Int64}:\n 1  5\n 2  6\n 3  7\n 4  8\n\njulia> readdlm(\"delim_file.txt\", Float64)\n4×2 Matrix{Float64}:\n 1.0  5.0\n 2.0  6.0\n 3.0  7.0\n 4.0  8.0\n\njulia> rm(\"delim_file.txt\")\n\n\n\n\n\n"},{"page":"Home","location":"#DelimitedFiles.readdlm-Tuple{Any}","title":"DelimitedFiles.readdlm","category":"method","text":"readdlm(source; options...)\n\nThe columns are assumed to be separated by one or more whitespaces. The end of line delimiter is taken as \\n. If all data is numeric, the result will be a numeric array. If some elements cannot be parsed as numbers, a heterogeneous array of numbers and strings is returned.\n\nExamples\n\njulia> using DelimitedFiles\n\njulia> x = [1; 2; 3; 4];\n\njulia> y = [\"a\"; \"b\"; \"c\"; \"d\"];\n\njulia> open(\"delim_file.txt\", \"w\") do io\n           writedlm(io, [x y])\n       end;\n\njulia> readdlm(\"delim_file.txt\")\n4×2 Matrix{Any}:\n 1  \"a\"\n 2  \"b\"\n 3  \"c\"\n 4  \"d\"\n\njulia> rm(\"delim_file.txt\")\n\n\n\n\n\n"},{"page":"Home","location":"#DelimitedFiles.writedlm","title":"DelimitedFiles.writedlm","category":"function","text":"writedlm(f, A, delim='\\t'; options...)\n\nWrite A (a vector, matrix, or an iterable collection of iterable rows) as text to f (either a filename string or an IO stream) using the given delimiter delim (which defaults to tab, but can be any printable Julia object, typically a Char or AbstractString).\n\nKeyword options:\n\nquotes::Bool=true:   if true, columns enclosed within double-quote (\") characters are allowed to   contain new lines and column delimiters. Double-quote characters within a quoted field must   be escaped with another double-quote.\n\nFor example, two vectors x and y of the same length can be written as two columns of tab-delimited text to f by either writedlm(f, [x y]) or by writedlm(f, zip(x, y)).\n\nExamples\n\njulia> using DelimitedFiles\n\njulia> x = [1; 2; 3; 4];\n\njulia> y = [5; 6; 7; 8];\n\njulia> open(\"delim_file.txt\", \"w\") do io\n           writedlm(io, [x y])\n       end\n\njulia> readdlm(\"delim_file.txt\", '\\t', Int, '\\n')\n4×2 Matrix{Int64}:\n 1  5\n 2  6\n 3  7\n 4  8\n\njulia> rm(\"delim_file.txt\")\n\n\n\n\n\n"}]
}
